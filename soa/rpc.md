# 何为rpc
rpc的全称为remote procedure call，即远程过程调用。什么是过程调用，我们在java中的一个方法中调用另一个方法，这就是本地调用。那远程的含义是什么呢？当今的服务架构逐渐偏向微服务架构，一个庞大的系统可以被拆分为许多的子系统，子系统不在同一个机器上，它们之间通过网络通信完成某个交互的动作，这就是远程调用。所以，远程的调用，一定离不开网络编程，不然怎么实现两个机器间的交互呢？

所以，为了完成这样一个跨机器调用的动作，我认为一个rpc框架应该做到的最基本的两点：

* 对调用者屏蔽网络通信的细节，让他们更专注于业务逻辑的编写
* 让远程调用跟本地调用无差异

# rpc如何通信
rpc最重要的应该就是网络的通信，通信的设计需要考虑哪些东西呢？

既然是网络的通信，那一定离不开协议（这里需要一些网络基础），rpc要做的事两个系统之间的数据交互，我们就可以使用TCP来传输，保证数据的安全性和完整性。

所有的数据给到网卡传输，都是以二进制的形式传输的，但是我们远程调用方法的参数是基本类型或是一个对象，一个对象转换为二进制，这就涉及到**序列化**，并且这个过程是可逆的。

到这里就完成了吗？当然不是，网络环境是相当复杂的，如果一个很大的数据传输到数据链路层，有可能会被拆分很多个包发送，这就导致接受方拿到的数据具有不确定性，数据是拆了还是没拆，第N次发过来的数据到哪结束了，知道了一条完整的数据我才可以序列化。所以，这就需要我们的协议起作用了我们发送的时候，在协议中添加一些元素，比如这次发送数据包的长度还有类型，这样接受方接受到数据后可以通过这些信息进行拆包。一般来说，协议分的内容可以分为数据头和消息体。数据头一般用于身份标识，比如序列化类型，请求类型等。消息体一般存放业务参数信息。

接受方拿到这个请求后，根据序列化类型对二进制数据进行反序列化，从而拿到请求参数。
# 如何对用户屏蔽掉用的细节
上面说到过，用户掉用的时候应该像调用本地方法一样进行调用，答案就是代理，这里不考虑代理的细节。invoke方法中其实就是一个网络掉用，这样做就对用户屏蔽掉了细节
# 开始设计完整的rpc
根据前面的内容，总结的一句话就是：rpc其实就是拦截调用的方法参数，转换为可以通信的二进制字节流，并可以保证服务可以还原这个语义，最终实现调用远程方法像调用本地方法一样的目的。

我们已经对rpc有了一个简单的认识，但是中间的细节，还是值得好好设计一下的。设计某个东西我们往往是自顶向下的一种设计思路，现在不妨问自己一个问题：什么是rpc？我觉得100个人有100个答案，先说我的理解：rpc就是通过特定的网络协议、可逆的序列化方式、代理设计模式，实现让调用方如同本地调用一样实现两个不同机器间的调用，即远程过程调用。在我的理解中，我已经把rpc粗略的划分为了3个模块，协议模块，序列化模块，网络通信（网络通信用代理模式来实现）模块。

根据上面的结论我们可以画出一个大概的架构草图。

## 网络协议
在设计协议前，需要对网络的传输过程有一定的了解。

网卡在传输数据的时候是二进制形式，大体流程就是RPC请求将请求的数据按某种方法转为二进制；转为二进制后写入本地的socket，然后网卡发送数据给另一台设备。

但是在这个过程中，网络有时候并不会将数据一次性发给另一台设备的，有时候会将数据拆分为好几个数据包，也可能合并同一个TCP请求下的数据包进行发送。为什么这么做呢，当然是数据太大了，有的人可能会说压缩，压缩有时候也起不到积极效果，所以可以将一个大的数据包拆分为小的进行发送。那么另一端的机器就会收到同一个请求的不同数据包，那该怎么区分呢？

解决办法就是，我们需要在发送数据的时候设置一个边界，收到请求的设备通过这个边界划分，拿到真正的数据，这个就是协议要做的事情。

RPC协议同HTTP协议一样，都属于应用层协议。但是HTTP协议已经相当成熟了，我们为什么不用HTTP协议呢？我认为有几个原因：

* RPC协议最重要的是快，HTTP协议有很多冗余的内容，不够简洁高效
* HTTP是无状态的协议，客户端无法对请求和响应进行关联

所以一个简单的协议可以设计成这样，通过读取固定长度中的值来读取协议体中的真正内容

但是这个协议过于简单了，一个真正的RPC请求要复杂一些，除了上面协议的长度意外，协议头中还需要以下的信息：

* 序列化方式：协议是二进制传输的，我们将二进制字节流的数据发送到一个设备，那这个设备该如何还原出语义呢，这就需要告诉别人序列化方式，让别人能正确还原出语义。
* 消息ID：消息的唯一标识，可以使用AtomicInteger自增的方式
* 协议的版本：需要做请求和响应的一一对应
* 消息类型：标识这个消息是请求/响应
* 魔术位：可以自行百度
* 扩展位：灵活设计，考虑到以后新增参数可以用扩展到bit位

## 序列化
序列化，我们其实不需要设计，因为有很多成熟的序列化方式。序列化在RPC中的作用就是：调用者将请求的方法参数等以二进制的方法发送给提供者，提供者需要根据协议中的序列化方法，安全的反序列化出二进制字节流，并保证语义的正确。

在RPC中，序列化的方式应该是：安全性 > 性能 > 空间开销

所以根据这个原则，我们可以选择Hessian 与 Protobuf，这两种足够满足我们的需求，想要详细了解的可以百度。
## 网络通信
关于IO相关的在我的另一篇文章，这里我们直接使用Netty这个开源的高性能IO框架。

