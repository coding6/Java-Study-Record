# 何为rpc
rpc的全称为remote procedure call，即远程过程调用。什么是过程调用，我们在java中的一个方法中调用另一个方法，这就是本地调用。那远程的含义是什么呢？当今的服务架构逐渐偏向微服务架构，一个庞大的系统可以被拆分为许多的子系统，子系统不在同一个机器上，它们之间通过网络通信完成某个交互的动作，这就是远程调用。所以，远程的调用，一定离不开网络编程，不然怎么实现两个机器间的交互呢？

所以，为了完成这样一个跨机器调用的动作，我认为一个rpc框架应该做到的最基本的两点：

* 对调用者屏蔽网络通信的细节，让他们更专注于业务逻辑的编写
* 让远程调用跟本地调用无差异

# rpc如何通信
rpc最重要的应该就是网络的通信，通信的设计需要考虑哪些东西呢？

既然是网络的通信，那一定离不开协议（这里需要一些网络基础），rpc要做的事两个系统之间的数据交互，我们就可以使用TCP来传输，保证数据的安全性和完整性。

所有的数据给到网卡传输，都是以二进制的形式传输的，但是我们远程调用方法的参数是基本类型或是一个对象，一个对象转换为二进制，这就涉及到**序列化**，并且这个过程是可逆的。

到这里就完成了吗？当然不是，网络环境是相当复杂的，如果一个很大的数据传输到数据链路层，有可能会被拆分很多个包发送，这就导致接受方拿到的数据具有不确定性，数据是拆了还是没拆，第N次发过来的数据到哪结束了，知道了一条完整的数据我才可以序列化。所以，这就需要我们的协议起作用了我们发送的时候，在协议中添加一些元素，比如这次发送数据包的长度还有类型，这样接受方接受到数据后可以通过这些信息进行拆包。一般来说，协议分的内容可以分为数据头和消息体。数据头一般用于身份标识，比如序列化类型，请求类型等。消息体一般存放业务参数信息。

接受方拿到这个请求后，根据序列化类型对二进制数据进行反序列化，从而拿到请求参数。
# 如何对用户屏蔽掉用的细节
上面说到过，用户掉用的时候应该像调用本地方法一样进行调用，答案就是代理，这里不考虑代理的细节。invoke方法中其实就是一个网络掉用，这样做就对用户屏蔽掉了细节
# 开始设计完整的rpc
根据前面的内容，总结的一句话就是：rpc其实就是拦截调用的方法参数，转换为可以通信的二进制字节流，并可以保证服务可以还原这个语义，最终实现调用远程方法像调用本地方法一样的目的。

我们已经对rpc有了一个简单的认识，但是中间的细节，还是值得好好设计一下的。设计某个东西我们往往是自顶向下的一种设计思路，现在不妨问自己一个问题：什么是rpc？我觉得100个人有100个答案，先说我的理解：rpc就是通过特定的网络协议、可逆的序列化方式、代理设计模式，实现让调用方如同本地调用一样实现两个不同机器间的调用，即远程过程调用。在我的理解中，我已经把rpc粗略的划分为了3个模块，协议模块，序列化模块，网络通信（网络通信用代理模式来实现）模块。

根据上面的结论我们可以画出一个大概的架构草图。

## 网络协议
在设计协议前，需要对网络的传输过程有一定的了解。

网卡在传输数据的时候是二进制形式，大体流程就是RPC请求将请求的数据按某种方法转为二进制；转为二进制后写入本地的socket，然后网卡发送数据给另一台设备。

但是在这个过程中，网络有时候并不会将数据一次性发给另一台设备的，有时候会将数据拆分为好几个数据包，也可能合并同一个TCP请求下的数据包进行发送。为什么这么做呢，当然是数据太大了，有的人可能会说压缩，压缩有时候也起不到积极效果，所以可以将一个大的数据包拆分为小的进行发送。那么另一端的机器就会收到同一个请求的不同数据包，那该怎么区分呢？

解决办法就是，我们需要在发送数据的时候设置一个边界，收到请求的设备通过这个边界划分，拿到真正的数据，这个就是协议要做的事情。

RPC协议同HTTP协议一样，都属于应用层协议。但是HTTP协议已经相当成熟了，我们为什么不用HTTP协议呢？我认为有几个原因：

* RPC协议最重要的是快，HTTP协议有很多冗余的内容，不够简洁高效
* HTTP是无状态的协议，客户端无法对请求和响应进行关联

所以一个简单的协议可以设计成这样，通过读取固定长度中的值来读取协议体中的真正内容

但是这个协议过于简单了，一个真正的RPC请求要复杂一些，除了上面协议的长度意外，协议头中还需要以下的信息：

* 序列化方式：协议是二进制传输的，我们将二进制字节流的数据发送到一个设备，那这个设备该如何还原出语义呢，这就需要告诉别人序列化方式，让别人能正确还原出语义。
* 消息ID：消息的唯一标识，可以使用AtomicInteger自增的方式
* 协议的版本：需要做请求和响应的一一对应
* 消息类型：标识这个消息是请求/响应
* 魔术位：可以自行百度
* 扩展位：灵活设计，考虑到以后新增参数可以用扩展到bit位

## 序列化
序列化，我们其实不需要设计，因为有很多成熟的序列化方式。序列化在RPC中的作用就是：调用者将请求的方法参数等以二进制的方法发送给提供者，提供者需要根据协议中的序列化方法，安全的反序列化出二进制字节流，并保证语义的正确。

在RPC中，序列化的方式应该是：安全性 > 性能 > 空间开销

所以根据这个原则，我们可以选择Hessian 与 Protobuf，这两种足够满足我们的需求，想要详细了解的可以百度。
## 网络通信
关于IO相关的在我的另一篇文章，这里我们直接使用Netty这个开源的高性能IO框架。
## 代理
在RPC调用中，对用户需要屏蔽网络调用等细节，所以用户在调用的时候，就像是在调用本地方法。这里需要使用动态代理来实现。具体在RPC中怎么实现呢？RPC会给接口自动生成一个代理类，接口在被调用的时候，会执行代理类的方法体，所以在代理类的方法体中，我们可以加入远程调用的逻辑。

但是哪些接口需要被代理拦截呢，我们可以创建一个注解，然后在需要代理的接口上贴上这个注解，在spring容器启动后process beans时，扫描被这个注解注释的方法，然后将这些方法生成代理类。


```java
/**
 * @description 远程调用时，需要标识哪些接口需要被代理，该注解就是标识哪些接口需要被代理
 */
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Autowired
public @interface RpcClient {

    String version() default "1.0";
}
```
# 总结
经过上面的设计，一个简易的RPC框架就完成了，为什么说简易，因为它不具有集群能力。如果对于同一个接口的服务提供者有很多，但是这些对于服务调用着来说是透明的。这时候RPC又需要注意哪些地方呢，下面会涉及到高级的部分功能，比如服务发现，优雅上下线，超时处理，路由策略，负载均衡，异常重试等等功能

# 进阶RPC
## 服务发现
上面说过，RPC需要支持集群能力，那么服务发现就是一个重要的能力。如下图：


1. 服务注册：服务提供方启动后，将对外暴露的接口注册到注册中心，注册中心将服务的ip与接口名保存下来
2. 服务订阅：服务调用方启动的时候，去注册中心查找服务提供方的地址，缓存到本地，用于后续的远程调用

在这里我们选择开源的zk做分布式注册中心
## 健康检测
我们假设这样一个场景，某个服务提供方的服务部署了10个节点。接收请求的时候，根据一定的策略将请求发送到10个节点上。10个节点中，如果有一个节点因为某些原因“不健康”了，那么请求还会打到这个节点上吗？

答案是看情况！

如果调用方在请求的时候，刚好这段时间网络有问题，那么请求还是会打到这个节点上，但是因为网络的问题，所以他只能处理一小部分的请求，这个时候，大家应该发现，这个节点应该算作不健康节点，因为他像是“半死不活”的状态，应该被下线。

既然清楚了原因，那我们就要想解决办法了，办法就是把不健康的节点下线掉，下线很容易，从列表中移除就行，那怎么样才算是不健康呢？

什么事心跳检测呢，就是在建立了TCP连接后，服务调用方定期问候一下服务提供方，如果规定时间内有回应，说明这个服务提供方的该节点有心跳。
1. 健壮状态：节点之间建立连接成功，心跳检测一直通过
2. 半死不活状态：连接成功，心跳检测连续不通过
3. 死球了状态：连接不成功

所以对于上面的问题，请求在健康状态下会正常打到某个节点上，在半死不活状态下有部分请求可以到达，死球了状态。。。。。

所以我们的策略是，在请求的时候从健康节点列表中选择一个节点接收请求，为了可用性，没有健康节点的时候就从半死不活的列表中选择一个接收请求。如果大家都死了，那就请求不处理了返回错误。


这几个状态间存在一个状态机，状态之间流转的条件是什么呢，达到什么条件，一个节点需要从健康状态被转移到半死不活状态。答案是**可用率**，可用率 = 请求成功次数/总调用次数，比如说，当可用率低于90%的时候，你就可以任务这个节点半死不活了，当然，这个值你自己定。这时候就需要把这个节点挪到半死不活节点。