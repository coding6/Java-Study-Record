​	

#  	JVM及其性能调优

## 第一章   Java基础回顾

Java内存模型是Java基础的核心，对并发编程有很大的帮助，由于Java程序是交给JVM执行的，所以我们在谈Java区域内存分配时事实上是指JVM内存区域的划分。

首先，我们来回顾一下Java程序的执行流程：

![Java执行过程](/Library/Typora所需图/Java执行过程.png)

在上图中，首先将Java源代码文件(.java)文件编译为字节码文件(.class)文件，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕后，交由JVM执行引擎执行，在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

### 1.1 类加载机制

在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的

（1）装载 

* 通过一个类的全限定路径找到此类去生成二进制流 

## 第二章  Java内存区域与内存溢出异常

### 2.1   运行时数据区域

​	JVM在执行程序时，会将它所管理的内存划分为若干个不同的区域，这些区域有各自的用途，以及创建和销毁的时间，有以下几个运行时的数据区域。

![](/Library/Typora所需图/运行时数据区.jpeg)

#### 2.1.1   程序计数器

​		程序计数器就是一个指令地址寄存器。在JVM概念模型中，字节码解释器通过改变计数器的值来选取**下一条需要执行的字节码指令**。

​		JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，每条线程都需要一个独立的程序计数器，各自之间的计数器互不影响，独立存储，这类内存区域为“线程私有”的内存，程序计数器的使用让多线程得以执行

​		如果线程正在执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空。这个内存区域是唯一一个在JVM中没有规定任何OutOfMemoryError情况的区域。

#### 2.1.2   Java虚拟机栈

​		与程序计数器一样，Java虚拟机栈也是线程私有的，虚拟机栈描述的是**Java方法**执行的内存模型，每个方法执行的时候都会创建一个**栈帧**（方法运行时期一种基础的数据结构）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。**每一个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程**。比如单线程程序，main方法一定先执行，所以main栈桢一定先入栈，当main方法执行到调用其他函数时，将这个函数的栈桢入栈。

​		遇到赋值语句，先拿到赋值的值将其入操作数栈，然后将局部变量表存储赋值语句的标识符名称，然后操作数栈出栈，将值赋给局部变量表的变量。

​		当进入一个方法时，这个方法需要在帧中分配多少空间是完全确定的。

​		在JVM中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果扩展JVM，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

#### 2.1.3   本地方法栈

​		和虚拟机栈所发挥的作用差不多，为虚拟机使用到的Native方法服务。

#### 2.1.4   Java堆

​		Java堆是JVM所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存区域**，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象全部实例都放在这里进行内存分配，所以，Object obj = new Object();这种，会将对象实例放在堆内存中，但是这不是静态的，所以栈中存放的就是这个对象在堆中的地址，有一个指针从栈指向堆。

​		Java堆是垃圾收集器管理的主要区域，也称“GC堆”。Java堆还可以细分：新生代和老年代；还有Eden空间、From Survivor空间、To Survivor空间。从内存分配角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。无论如何划分存储的仍然是对象实例，当堆也无法完成内存实例分配，并且无法再扩展时，抛出OutOfMemoryError异常。

#### 2.1.5   方法区

​		方法区和Java堆一样，**线程共享**，用于存储**已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**，方法区是堆的一个逻辑部分，但还是应该与堆区分开来。这个区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载。方法区是java虚拟机规范去中定义的一种概念上的区域，具有什么功能，但并没有规定这个区域到底应该位于何处，因此对于实现者来说，如何来实际方法区是有着很大自由度的。

永生代是hotspot中的一个概念，其他jvm实现未必有，例如jrockit就没这东西。java8之前，hotspot使用在内存中划分出一块区域来存储类的元信息、类变量以及内部字符串（interned string）等内容，称之为永生代，把它作为方法区来使用。

[JEP122][2]提议取消永生代，方法区作为概念上的区域仍然存在。原先永生代中类的元信息会被放入本地内存（元数据区，metaspace），将类的静态变量和内部字符串放入到java堆中。

**为了弄清楚方法区那么需要解释两个名词：永久代和元空间**

**PermGen(永久代)**--方法区的实现

绝大部分Java程序员应该都见过“java.lang.OutOfMemoryError: PremGen space”异常。这里的“PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现，并且只有HotSpot才有“PermGen space”，而对于其他类型的虚拟机，如JRockit(Oracle)、J9(IBM)并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。并且JDK 1.8中参数PermSize和MaxPermSize已经失效。

**元空间**--方法区的实现

移除永久代的工作从JDK1.7就开始了。在JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap（java堆）或者Native Heap（本地堆）。但永久代仍存在与JDK1.7中，并没有完全移除，譬如引用符号（Symbols）转移到了Native Heap；字面量（Interned Strings）转移到了Java Heap；类的静态变量（Class Static）转移到了Java Heap。

JDK1.8对JVM的架构的改造将类元数据放到本地内存中·，另外，将常量池和静态变量放到Java堆中，HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来-XX:MaxPermSize的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成的大量类经常造成Full GC问题，如运行时使用反射，代理等。所以升级以后Java堆空间可能会增加。

#### 2.1.6   运行时常量池

​		运行时常量池是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于**存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。

​		运行时常量池有一个重要的特征是具备动态性，Java语言并不要求常量一定只能在编译期产出，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的便是String类的intern()方法。

#### 2.1.7   直接内存

​		直接内存并不是虚拟机运行时数据区的一部分，但是也可能导致内存溢出异常

### 2.2   对象访问

​		Object obj = new Object();

​		这句话“Object obj”将会反映到Java栈的本地变量表中，作为一个引用类型出现。而“new Object()”这部分的语义将会反映到Java堆上，形成了一块存储了Object类型所有实例数据值的结构化内存。另外，在Java堆中还必须包含能查找到此对象类型数据（对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据存储在方法区中。

​		由于引用类型在Java虚拟机规范里只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。

​		☆  句柄访问：Java堆会划分出来一块区域做句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。

 		☆  直接指针访问：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，引用中直接存储的就是对象地址。

​		两种方式各有优势，句柄池好处在于reference中存储的是句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改；直接指针好处在于速度较快，节省了一次指针定位的时间开销。

![](/Library/Typora所需图/JVM内存模型.png)

| 名称         | 特征                                                     | 作用                                                         | 配置参数 | 异常                                |
| :----------- | -------------------------------------------------------- | ------------------------------------------------------------ | -------- | ----------------------------------- |
| 程序计数器   | 占用内存小，线程私有，生命周期与线程相同                 | 大致为字节码行号指示器                                       | 无       | 无                                  |
| 虚拟机栈     | 线程私有，生命周期与线程相同，使用连续的内存空间         | Java方法执行的内训模型，存储局部变量表，操作栈，动态链接，方法出口等信息 | -Xss     | StackOverflowError OutOfMemoryError |
| Java堆       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 保存对象实例，所有对象实例（包括数组）都要在堆上分配         |          | OutOfMemoryError                    |
| 方法区       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 |          | OutOfMemoryError                    |
| 运行时常量池 | 方法区的一部分，具有动态性                               | 存放字面量及符号引用                                         |          |                                     |

### 2.3 堆的内存布局

![堆空间](/Library/Typora所需图/堆空间.png)

### 2.4 内存泄漏与内存溢出

OOM(内存溢出)，JVM堆没有足够的空闲内存，并且垃圾收集器也无法提供更多的内存

Memory Leak(内存泄漏)，严格来说，只有对象不会再被程序用到，但是又GC不了，才叫内存泄漏；但实际情况中有一些不太好的实践会导致对象的生命周期变得很长导致OOM，也可以叫做内存泄漏

比如：单例模式下对象的生命周期和程序一样长，如果一个对象依赖这个单例对象，那么这个外部对象很可能没法被回收

## 第三章	垃圾收集器

### 3.1 概述

​		垃圾收集（GC），我们考虑的三个问题？

​		①那些内存需要回收？

​		②什么时候回收？

​		③如何回收？

​		我们只关心堆内存的回收与分配机制

### 3.2 判断对象是否需要回收

​		新生代：生命周期较短的对象

​		老年代：生命周期较长的对象

#### 3.2.1 引用计数算法

​		有引用对象的地方，计数器+1；引用失效，计数器-1，任何时刻计数器为0的对象就是不可能再被使用的。

​		引用计数算法简单，Java并没有用，因为很难解决对象之间相互循环引用的问题。

#### 3.2.2 根搜索算法

​		Java语言使用根搜索算法判定对象是否存活。使用这个方法，需要有一个起始节点（GC ROOT），从起始节点开始向下搜索，搜索走过的路径称为引用链，当GC ROOT无法到达一个对象，就是说它们之间没有引用链的时候，证明此对象需要被回收。

​		在Java语言里，可作为GC ROOT的对象包括下面几种：

​		①虚拟机栈中的引用变量

​		②方法区中的类静态属性引用的变量

​		③方法区中的常量引用的对象

​		④Native方法的引用的对象

#### 3.2.3 引用类型

​		JDK1.2以前，Java中的引用的定义很传统：如果引用类型的数据中存储的数值代表的是另外一块内存的起始地址，那么就称这块内存代表着一个引用。

​		JDK1.2之后，Java对引用的概念进行了扩充，分为**强引用、弱引用、虚引用，软引用**。

​		**强引用**：指在代码中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象

​		**软引用：**指有用的，但是非必须的对象，内存将要发生溢出异常之前，将会把这些对象列进回收范围中并进行第二次回收

​		**弱引用：**无论内存是否足够，直接回收

​		**虚引用：**为对象设置虚引用关联的目的就是希望这个对象被回收时收到一个系统通知。

#### 3.2.4 生存还是死亡(如果回收时需要给一个对象添加引用)

​		根搜索无法达到的，就是没有与引用链相连接的，并不是非死不可，对象进行根搜索后发现没有引用链与其相连，它将会第一次被标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者该方法已经被虚拟机调用过，虚拟机都视为“没有必要执行”。

​		如果判定这个对象有必要执行finalize()方法，那么这个对象将会被放置在名为F-Queue的队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里的执行是指虚拟机会触发这个方法，但是并不会等待他运行这个方法结束。因为一个对象如果运行finalize()十分缓慢，出现了死循环或者等待，那么F-Queue队列中的所有对象都要处于永久等待状态，导致回收系统崩溃。稍后GC会对F-Queue进行第二次小规模的标记，把自己与引用链上的任意一个对象建立关联即可活命。那么在第二次标记时会被移出回收的集合活命下来。

#### 3.2.5 回收方法区

​		方法区即HotSpot虚拟机中的永久代，永久代的垃圾回收主要两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象十分相似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入常量池中，但是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果必要的话，会被请出常量池。

​		在判断是否是无用的类时，

​		1.该类的所有实例都已经被回收，Java堆中不存在该类的任何实例。

​		2.加载该类的ClassLoader已经被回收

​		3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 3.3 垃圾收集算法

#### 3.3.1 标记-清除算法

​		顾名思义就是分为标记和清除两步，首先标记出所有要回收的对象，在标记完成后统一回收掉所有被标记的对象，但是其效率低下，并且清理后会产生大量不连续的内存碎片，这样会导致系统如果需要分配连续的内存空间而无法找到引起提前的另一次垃圾收集动作。

#### 3.3.2 标记-复制算法

​		它将可用的存储空间划分为两部分，大小相等，每次用其中的一块，这一块的内存用完了，就将还存活的对象复制到另外一块上去，然后再把已经使用过的内存一次性清理掉。surviveor区经常使用该算法，缺点就是空间浪费很大，要有一半是空出来的

#### 3.3.3 标记-整理算法

​		标记过程与“标记清除”算法一样，后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。针对老年代，每次回收都有大量对象存活区域，如果移动存活对象，这将是一种极为负重的操作，会引起STW，

#### 3.3.4 分代收集理论

​		新生代的话，用复制算法，因为没过多久会有大批的对象死去，老年代用标记清除或标记整理

### 3.4 垃圾收集算法实现细节

#### 3.4.1 根节点枚举

​		GC Root寻找引用链时，需要先找到引用的起源，Java应用的庞大导致逐个检查会耗费很多的时间。迄今为止，所有的收集器在根节点枚举这一步都是必须暂停用户线程的（STW）。不用进行全局上下文的查找，HotSpot使用OopMap记录什么地方有引用

#### 3.4.2 记忆集与写屏障

一个区对象被不同区引用的问题，使用记忆集解决。因此不需要扫描整个堆，尤其是G1的记忆集维护起来相当的复杂

解决办法：

引用类型在写操作的时候都会产生一个**写屏障**暂时中断操作，记录一下引用是不是夸代引用，如果夸代了，通过卡表把相关引用信息记录到引用指向对象的所在Region对应的记忆集当中，GC时，将记忆集加入根节点枚举的范围

### 3.5 垃圾收集器

#### 3.5.1 Serial收集器

​		**收集新生代**

​		这个收集器是一个单线程的收集器，它在进行垃圾收集工作时，必须暂停其他所有的工作线程，直到它收集结束。

​		它依然是虚拟机运行在Client模式下的默认新生代收集器。优点也有很多简单高效（与其他收集器的单线程相比），没有线程交互的开销，专心做垃圾收集，收集桌面应用垃圾。

#### 3.5.2 ParNew收集器

​		**收集老年代**

​		ParNew是Serial收集器的多线程版本，单CPU的环境中绝对不会有比Serial收集器更好的效果，随着CPU数量的增加，这种方式还是很有好处的。

#### 3.5.3 Parallel Scavenge收集器

​		**收集新生代**

​		它也是一个新生代收集器，使用复制算法的收集器，也是并行多线程的收集器，前面的收集器大多数关注缩短垃圾收集时用户线程的停顿时间，但是Parallel Scavenge目标是达到一个可控制的吞吐量，虚拟机运行了100分钟，垃圾收集花掉了1分钟，那么吞吐量就是99%。

​		停顿时间越短越适合需要与用户做交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快的完成程序的运算任务，，主要适合在后台运算而不需要太多交互的任务。

#### 3.5.4 Serial Old收集器

​		**收集老年代**

​		Serial Old是 Serial收集器的老年代版本，同样是单线程，使用“标记-整理”算法，它的意义还是在被Client模式下的虚拟机使用。如果是Server模式下，它主要还有两大用途：一个是在JDK1.5以前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。

#### 3.5.5 Parallel Old收集器

​		**收集老年代**

​		Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理“算法。在这个收集器之前，Parallel Scavenge收集器一直处于尴尬状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器外别无选择（Parallel Scavenge与CMS无法配合工作）。由于单线程的老年代Serial Old收集器在服务端应用性能上的“拖累”，Parallel Old出现之后，可以考虑Parallel Scavenge加Parallel Old收集器。·

#### 3.5.6 CMS收集器

​		CMS收集器是一种以最短回收停顿时间为目标的收集器，这样能给用户带来较好的体验

​		这是一款基于“**标记-清除**”算法实现的收集器，有四个步骤：

​		① 初始标记

​		② 并发标记

​		③ 重新标记

​		④ 并发清除

​		其中初始标记、重新标记两个步骤都是需要暂停其他线程。初始标记仅仅只是标记一下GC ROOTS能直接关联到的对象，速度很快，并发标记阶段就是进行GC ROOTS Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些。CMS使用记忆集去维护对象关系

​		总体来说CMS收集器的内存回收过程是与用户线程一起并发地执行的。

​		但是它有三个缺点：

​		1.CMS收集器对CPU资源非常敏感，虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。

​		2.CMS收集器无法处理浮动垃圾回收垃圾时用户程序还在运行，所以还会有新的垃圾不断产生，这些垃圾出现在标记之后，CMS无法在本次收集中处理掉它们。在这期间如果内存不够了不够并发产生的对象分配了，解决方法最差是启动serial old进行收集	

​		3.它的“标记-清除”会造成收集结束有大量空间碎片，无法分配连续的足够的空间给别的对象，不得已的时候进行标记-整理

#### 3.5.7 Garbage First收集器

它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。

 在G1以前，垃圾收集的目标要么是新生代，老年代或者整个堆，但是在G1时，分代收集的理论基础还在，但是它可以面向堆内存任何部分来组成回收集(CSet)，哪块垃圾多，就回收哪块，回收收益最大。把Java堆划分为连续的独立的Region，每一个Region都可以根据需要扮演新生代的Eden空间，Survivor空间和老年代空间。

G1认为只要超过一个Region容量一半的对象即可判定为大对象，Region的大小可以根据参数-XX:G1HeapRegionSize来设置，这些大对象都会被存储在一类叫Humongous的区域中。

稍微具体一点的收集思路是，G1需要去跟踪各个Region的垃圾价值大小，回收所得的空间大小以及回收所需的时间的经验值。然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的Region。

G1还有些问题，留给了后续的收集器解决：

* 跨带引用的问题：之前的CMS等等如果有新生代引用了老年代的对象，通过记忆集等数据结构记录即可，但是这些在G1中十分乏力，因为G1的记忆集设计十分复杂，因为堆被分成了许多个region，每个region都维护有自己的记忆集，region的数量比传统的分代收集数量要多的多，G1会十分消耗内存
* 并发阶段如何保证收集线程与用户线程互补干扰运行？必须保证用户改变对象的时候不能打破原有的对象图结构导致标志出错，G1通过原始快照方式实现（SATB），CMS是通过增量更新
* 最后回收依旧需要暂停用户线程，因为使用了标记-整理，移动对象最好还是STW

**G1也大致分四个阶段：**

初始标记：和CMS差不多

并发标记：扫描整个堆里的对象图，找出要回收的对象，耗时比较长，扫描完成后要重新处理SATB记录下的在并发时有引用变动的对象。

最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后仍遗留的最后少量的SATB记录。

筛选回收：评估回收价值，Region中存活的对象复制到空的Region中，清空之前的Region，必须暂停用户线程，这里是由多个收集器并行完成的。

G1收集器从全局来看是使用了“标记-整理”算法，但是两个region之间又是基于“标记-复制”算法，这与CMS的“标记-清除”算法不同，这意味着相对于CMS，G1不容易在回收后产生垃圾碎片，所以不容易因为无法找到连续的空间分配内存而提前触发下一次收集。最大的功能就是在用户指定的时间内收集有最大效益的region。

#### 3.5.8 Shenandoah收集器

Shenandoah相对于G1，内存布局是基本一致的，有region和存放大对象的Humongous region，默认的回收策略也是回收收益价值最大的Region，Shenandoah支持并发整理，G1的回收阶段是支持并行的。Shenandoah是默认不适用分代收集。Shenandoah摒弃了G1中消耗大量资源去维护的记忆集，使用叫“连接矩阵”的全局数据结构来记录Region的引用关系。

Shenandoah大致以下几个阶段：

并发标记：与G1一样，标记处全部可达对象

最终标记：与G1一样，在这个阶段统计出回收价值最高的Region，会有短暂停顿。

并发清理：清理整个区域一个存活对象都没有找到的Region

并发回收：这里就是与其他收集器不同的地方，支持与用户线程并发对垃圾进行回收。

Shenandoah支持并发回收的核心是Brooks Pointer（转发指针），在原有的对象结构上加一个Brooks Pointer指向自己的Header ，当对象拥有了一份新的副本，就是旧对象被移动到新的region的时候，只需要修改这个指针的指向，即旧对象上的转发指针的引用位置使其指向新对象。

#### 3.5.9 ZGC收集器

ZGC内存布局分为大中小三种Region，ZGC是怎么解决并发回收的问题的呢，Shenandoah使用了转发指针和读屏障。ZGC使用了读屏障和染色指针。

ZGC与Shenandoah和G1不同的地方在于：

* 染色指针在某个Region的存活对象被移走之后，这个region会立即被释放掉，不必等待整个堆中所有的指向这个region都被修改后才能清理。这与Shenandoah不一样，相比Shenandoah是一个优势，这就使得理论上只要有一个空闲的region，ZGC就可以完成收集，
* 染色指针可以大幅度减少在垃圾收集中内存屏障的使用，能够提升效率
* G1使用大量精力去维护回收集和记忆集，ZGC扫描全堆，ZGC重分配集中存活的对象会被分配到新的region中，旧的会被释放去用于新对象的分配，在并发重分配的时候，得益于染色指针，直接修改引用的值指向新的对象，这就是指针的“自愈”，相比Shenandoah，旧的内存不能清空，相比Shenandoah的转发指针，一次就可以到位，转发指针每次访问都要付出开销

ZGC和Shenandoah都做到了几乎全过程并发，除了GC root时候短暂停顿。

## 第四章 虚拟机类加载机制

### 4.1 类加载的时机

一个

### 4.3 类加载器

"通过一个类的全限定名去获取描述该类的二进制字节流"这个动作放到虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。

#### 4.3.1 类与类加载器

### 4.4 双亲委派模型

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会送到顶层的启动类加载器中，只有当父类无法完成时，子类加载器才会尝试自己去完成。

这种方式加载类显而易见的好处是，无论哪一个类加载器要加载这个类，最终都要委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能保证是同一个类。防止出现和JDK自带的类名相同的类，可以正常编译，但是无法加载运行	

## 第五章 String

### 5.1 字符串的拼接

```java
String s1 = "a"+"b";
String s2 = "ab";
sout(s1==s2);
```

这个结果是返回true的，因为虽然是拼接，但是是常量拼接，常量拼接是存储在常量池中，所以两个是一样的，返回true，这一种拼接没有使用StringBuilder，这一种是编译期优化

```java
String s1 = "a";
String s3 = "b";
String s2 = "ab";
String s4 = s1+s2;
String s5 = "a"+s3;
sout(s4==s2);
sout(s5==s2);
```

这个就返回false了，不论值是否相等，因为在字符串后面+一个**变量**！！！！的时候，相当于做了几步操作：

* StringBuilder s = new StringBuilder();
* s.append(s1)
* s.append(s2)
* s.toString();

toString的源码是new String();-----new String是在堆空间(除常量池以外)的空间分配，所以地址肯定不一样()

```java
final String s1 = "a"+"b";
final String s2 = "ab"+s3;
sout(s1==s2);
```

加了final关键字之后，这就是一个常量的表现形式，所以返回true。

### 5.2 intern()方法



