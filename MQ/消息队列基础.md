# 消息队列
## overview
简单来说，消息队列就是一个用队列来通信的组件
## 为什么需要消息队列
系统越来越复杂，所以互联网架构必须与时俱进，消息队列的诞生，主要用来：异步处理，流量控制，服务解耦，削峰填谷等
### 异步处理
有的系统中调用的链路可能刚开始还好，但是可能后续又会新加进来几个服务，导致一个请求的链路变长，用户需要等待很久，调用链路长了，系统的响应就慢很多。这时候消息队列登场，比如在电商的下单流程中，比较重要的就是减库存且提交订单，但是短信通知这些不重要的服务没必要加在主流程中，提交订单后就算成功了，将结果返回给客户，将成功的消息塞到消息队列中，短信通知等服务消费到成功消息后再发送短信。
### 服务解耦
一个系统需要在不同的时机进行扩展，比如说订单服务，我们可能需要扩展一个数据分析服务，那么这些下游的扩展服务修改可能就会影响到订单服务，这就是服务于服务之间的耦合性太高，所以我们将订单产生的消息放到消息队列中，谁需要就订阅这个topic。
### 流量控制
消息队列还可以做**流量控制**，比如在抢红包、秒杀等短时高并发特征的系统中，流量会在一个集中的时间点涌入，这时候后端没有那么大的能力处理这些并发的请求。所以可以先将这一部分的请求放入消息队列中，后端从消息队列中慢慢取慢慢消化。
## 队列模型
消息队列的模型有两种：**队列模型**和**发布/订阅模型**
### 队列模型
队列模型是生产者向队列中push消息后，多个消费者竞争的去获取消息，一个消息只能被一个消费者消费。
### 发布/订阅模型
该模型下，生产者需要将消息push到指定topic的队列中，所有订阅了这个topic的消费者都可以消费这条消息
### 两者对比
**队列模型**下一个消息只能被一个消费者消费，也可以通过相同消息全量存储到多个队列实现一个消费者各消费一个消息，但是会有数据冗余。

**发布订阅模型**通过topic实现了多个消费者都可以消费同一个消息的功能。较为主流。
## 如何保证消息不丢失

一般来说，代码编写得当，消息都不会丢失

![](/asset/消息队列消息通知.png)
### 生产者发送消息
生产者向Broker发送消息，不论是同步还是异步发送消息，都需要在代码做好try/catch，如果返回的通知是写入失败等，需要重试发送。多次失败后需要做日志记录或报警，**这样就保证了在生产消息阶段消息不会丢失。**
### Broker存储消息
消息存储阶段需要在数据写入磁盘后再返回给生产者成功的通知，如果是写入内存如果这时候宕机了，那消息就没了。如果是集群部署，那至少要写入两个机器中，再返回响应
### 消费者拉取消息
消费者拿到消息后不能立刻通知Broker成功，需要走完消费的逻辑后再返回success，这样就能保证消费阶段的消息不丢失。
## 如何处理重复消息
消息重复是无法避免的，因为网络抖动等原因导致生产者重发一次消息，此时就有两条一模一样的消息会存在于Broker，但是网络抖动这种是无法避免的。那我们就另辟蹊径：消息幂等，即重复的消息不会给业务带来什么影响。
我们可以给消息加上一个version，在ROK中就是通过jobId+version作为一个唯一标识判断消息是否是重复的。
## 如何保证消息有序性
一个topic下有可能有多个队列，那么如果严格有1，2，3的顺序push进去，但是消费的时候就不一定是1，2，3取出来。RocketMQ提供了选择机制，比如同一个订单的下单支付等消息可以通过Hash取模法放进同一个队列（同一个订单号Hash肯定是一样的嘛），那么消费这个队列的时候肯定是按下单，支付的顺序消费的呀
## 如何处理消息堆积
* 看看代码有没有bug导致消费很慢
* 采用多线程消费
* 水平扩容，加几个消费者和队列