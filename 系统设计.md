# 高并发系统设计
## 秒杀
### overview
秒杀系统的特点就是短时高并发，流量洪峰集中在短短一段时间，比如抢手机，商家做活动的手机有100台，但是抢购的人数达到了好几万。最终的正确的结果是只有100个人可以抢到手机，剩下的人都无法抢到，不能产生超买超卖的现象。
### 秒杀系统存在的问题
**高并发**

高并发是秒杀系统最显著的特征，秒杀开启的一刻，有无数的请求打到服务器。不做处理，很容易就把服务挤爆。用户的请求可能还算正常，黄牛什么的写个脚本，模拟几万人抢，那就GG了。

**超卖**

商家只准备了100台手机，不能卖101台

**数据库QPS高**

数据库的压力很大，因为秒杀是一个读多写少的场景，几万到几十万的QPS打到数据库是很伤的。
### 对症下药

> 请求进入前端

1. 前端可以在秒杀开启前将按钮置灰，不允许点击，因为开放按钮可以获取到秒杀链接的URL，拿到URL黄牛就可以写脚本进行疯狂请求。
2. 前端可以将部分静态资源上传cdn服务器，尽可能的优化性能
3. 前端限流，秒杀按钮不能一直点击。

> 请求到后端

1. 读多写少，当然是要上redis啦，用redis了，当然要集群啦
![](/asset/redis集群架构.png)
2. 并发量大，使用Nginx，普通Tomcat能顶几百并发，带上Nginx，就能好几万了。
3. 限流，100个商品抢完了，直接return，不用走后续无效的请求了。当然还可以使用限流的组件等等
4. 库存预热，每个请求都去查询数据库校验库存，减库存，数据库顶不住。提前把一部分商品库存提前加入redis中
5. 防止超卖，分布式架构，多个节点发现此时库存还有1，这时减库存的操作需要改成原子操作。redis提供了Lua脚本，把判断库存和减库存放在脚本中交给redis去做
6. 秒杀可以单独写一个服务，因为秒杀还需要下单，支付等服务，秒杀挂了不能影响其他服务。（服务的限流，降级，熔断，隔离）
7. 秒杀是有短时高流量的特征，我们可以使用MQ来进行削峰填谷，可以把秒杀的请求放到消息队列中，一点点消费去改库存，单个商品修改一次。

### 数据库设计
**订单信息表**
```sql
CREATE TABLE 'order_info'(
    'id' int(10) unsigned NOT NULL AUTO_INCREMENT COMMIT '主键',
    'order_id' varchar(50) NOT NULL COMMIT '订单号',
    'merchant_id' int(10) NOT NULL COMMIT '商家id',
    'user_id' int(11) NOT NULL COMMIT '用户id'，
    'order_amount' int(10) NOT NULL COMMIT '订单金额大小'
)
```
**订单商品信息表**
```sql
CREATE TABLE 'order_product_info'(
    'id' int(10) unsigned NOT NULL AUTO_INCREMENT COMMIT '主键',
    'order_id' varchar(50) NOT NULL COMMIT '订单号',
    'product_id' int(10) NOT NULL COMMIT '商品id，跟商家id组合查询作为唯一key',
    'goods_num' int(10) NOT NULL COMMIT '下单数量'
)
```
### redis在其中的作用
秒杀本质上就是对库存的高并发操作，业务场景就是一个读多写少的场景，先判断库存，符合条件再下单，不符合了直接return false，不走后续的流程减少服务器的压力。